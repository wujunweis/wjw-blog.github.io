<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue Interview</title>
      <link href="/wjw-blog.github.io/2020/11/17/vue-interview/"/>
      <url>/wjw-blog.github.io/2020/11/17/vue-interview/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue-常见面试题"><a href="#Vue-常见面试题" class="headerlink" title="Vue 常见面试题"></a>Vue 常见面试题</h1><h2 id="必问：Vue-生命周期-以及生命周期内各自做了什么"><a href="#必问：Vue-生命周期-以及生命周期内各自做了什么" class="headerlink" title="必问：Vue 生命周期 以及生命周期内各自做了什么"></a>必问：Vue 生命周期 以及生命周期内各自做了什么</h2><pre><code>开始之前我们先来看下流程图 2.x版本 3.x版本与之略有不同我们先看2.x</code></pre><p><img src="/wjw-blog.github.io/2020/11/17/vue-interview/vue-life-cycle.png"></p><blockquote><p>如图所示：vue 的每个组件都是独立的，每个组件都具备从创建、数据初始化、挂载、更新、销毁的过程，这个过程就是所谓的生命周期。</p></blockquote><ol><li>beforeCreate<br>在data初始化之前，event/watch等事件配置前调用，<code>换而言之这时候data还为被初始化这个地方是肯定拿不到data数据的</code></li><li>created<br>create 初始化计算属性（computed{}），event|watch事件回调但dom树并未挂载</li><li>beforemount<br>在挂载之前render函数首次被调用生成相应的虚拟dom，之后创建vue实例$el将其替换成为真正的dom</li><li>mounted<br>挂载完成，dom树已经完成渲染到页面，可进行dom操作（处理逻辑数据）</li><li>beforeUpdate、updated<br>beforeUpdate 数据有被更新就会调用，增加判断以最小的dom开支来渲染dom，updated 虚拟dom重新渲染</li><li>beforeDestroy<br>实例销毁之前，这里还是能够访问实例数据的。</li><li>destroyed<br>字面意思，实例已经被销毁（这里可以做一些取消自定义的一些事件或监听等操作，比如listener resize），<code>当然对象都不存在了值也就不会存在</code>，假设问你一个问题刷新页面会触发该方法么，答案是否定的，因为刷新页面是浏览器的主动行为（可以监听这个刷新 <code>window.addEventListenner(&#39;beforenunload&#39;, function()&#123; // you can cancel the event &#125;</code>)），当然该方法你也可以手动触发<code>$destroy()</code></li></ol><ul><li>对于3.x 版本更新很是很多的，首先理解钩子函数：伴随着生命周期，给用户使用的函数-&gt;操控生命周期，主指操控钩子函数，基本理念等同上所述，现在我们在看下3.x 版本：<ol><li>setup<br>在beforeCreate与created之前执行，创建的是data与method。（当然之前的逻辑都定义在setup函数内）</li><li>onBeforeMount<br>组件挂载到节点上之前执行的函数</li><li>onMounted<br>组件挂载完成</li><li>onBeforUpdate<br>组件更新之前执行</li><li>onUpdated<br>组件更新之后执行的函数</li><li>onBeforUnmount<br>组件卸载之前执行</li><li>OnUnmounted<br>组件卸载之后完成</li><li>onActivated<br>包含在<code>&lt;keep-alive&gt;</code>中的组件，会多两个生命周期函数，激活时执行</li><li>onDeactived 比如从A切换B，A组件消失时执行</li><li>onErrorCaptured 当补货一个子组件的异常时激活该钩子函数（增强了组件的健壮性，避免关联其他组件）</li></ol></li><li>对比table 如下<table><thead><tr><th>Vue2</th><th>Vue3</th></tr></thead><tbody><tr><td>beforeCreate</td><td>setup()</td></tr><tr><td>created</td><td>setup()</td></tr><tr><td>beforeMount</td><td>onBeforeMount</td></tr><tr><td>mounted</td><td>onMounted</td></tr><tr><td>beforeUpdate</td><td>onBeforeUpdate</td></tr><tr><td>updated</td><td>onUpdated</td></tr><tr><td>beforeDestroy</td><td>onBeforeUnmount</td></tr><tr><td>destroyed</td><td>onUnmounted</td></tr><tr><td>activated</td><td>onActivated</td></tr><tr><td>deactivated</td><td>onDeactivated</td></tr><tr><td>errorCaptured</td><td>onErrorCaptured</td></tr></tbody></table></li></ul><h2 id="computed-和-watch-区别"><a href="#computed-和-watch-区别" class="headerlink" title="computed 和 watch 区别"></a>computed 和 watch 区别</h2><ul><li>computed 是计算一个新的属性，并将该属性挂载到Vue实例上，而watch是监听已经存在且已经挂载到Vue实例上的数据，所以watch 同样可以监听computed 计算属性的变化。</li><li>computed 本质是一个惰性求值者，具有缓存性质，只有依赖变化后（第一次计算才会计算新的值）。而watch则是当数据发生变化后便会执行函数</li><li>从使用场景上说，computed适用<code>一个数据多个数据影响</code>，而watch适用<code>一个数据影响多个数据。</code></li></ul><h2 id="单页应用（SPA）有什么缺点？"><a href="#单页应用（SPA）有什么缺点？" class="headerlink" title="单页应用（SPA）有什么缺点？"></a>单页应用（SPA）有什么缺点？</h2><ol><li>首次加载耗时比较多。（需要解决FP Issue）</li><li>SEO问题，不利于搜索引擎收录（解决方案适用SSR）</li><li>容易造成Css命名冲突（可以加scoped，利用webpack分割多文件或者对应chunkname包）</li><li>前进、后退、地址栏、书签等都需要程序进行管理，页面复杂度很高<h2 id="一些一句话可以回答的问题"><a href="#一些一句话可以回答的问题" class="headerlink" title="一些一句话可以回答的问题"></a>一些一句话可以回答的问题</h2></li></ol><ul><li><p>active-class属性 属于哪个组件？<br>vue-router模块的router-link组件</p></li><li><p>router 跳转有几种<br>  声明式：标签跳转<code>&lt;router-link :to=‘link’&gt;</code><br>  编程式：js跳转 <code>router.push(&#39;home&#39;)</code><br>  <code>PS: window.location 与 window.history 也可跳转</code></p></li><li><p>接收router跳转参数？<br>  使用 <code>route.query.name</code>引入query的path <code>route.params.name</code>引入params的name</p></li><li><p>vuex 的getter 特性<br>  getter 可以对set进行计算操作，他就是store的计算属性，getters可以给多组件复用</p></li><li><p>vuex mutation 特性<br>  action 蕾丝 mutation，不同的是action 负责提交mutation 而不是直接变更状态。action 可以包含异步操作</p></li><li><p>vuex 的优劣势</p><blockquote><p>优点：1.拥有更好的可维护性。2。增强代码阅读性 3.解决一定的代码耦合程度。4. js原生数据对象，使用方便。 5. 触发式更新可避免重复更新。6. 限定可预期的方式更改数据，避免污染7.共享state 避免多次获取<br>缺点：1.增加代码逻辑复杂程度。2. 刷新vue state值丢失。（解决方案：可以使用vuex-persistedstate 或 h5存储）</p></blockquote></li><li><p>vue 几种常见属性<br>  state、getter、mutation、action、module （详细讲解请参考源码，后面也有解析）</p></li><li><p>vuex 原理<br>  vuex 只能使用在vue中，很大程度依赖于vue的computed依赖检测系统以及其插件系统。<br>  vuex 整体思想来源flux，响应式设计、依赖监听、依赖收集都属于vue对象property set get 的方法带六劫持。vuex中的store 本质就是没有template的隐藏着的vue组件</p></li><li><p>使用Vuex 只需要执行Vue.use(Vuex) ,store是如何注入的？<br>  vue.use(vuex)方法执行了install方法，它实现了vue实例上的init方法封装与注入，使用传入的store对象被设置到vue上下文环境中的store中。因此vuecomponent任何地方都可以使用this.store访问到该store</p></li><li><p>state内部支持模块配置和模板嵌套，如何实现的？<br>  store构造方法中有makeLocalContext 方法，所有module都会又一个local context，根据配置时的path 进行匹配，所以执行dispatch的action时，默认拿到的都是module的localState如果访问嘴歪成或者其他的module的state只能从rootState按照path路径逐步访问。</p></li><li><p>在dispatch 触发action commit 的时候只需要传入 type，payload，action执行函数第一个参数store在哪里获取的？<br>store 初始化的时候所有配置的action和mutation以及getters均被封装过，在执行如dispatch（‘submit’， payload）的时候，actions中的type为submit的所有处理方法都是被封装后的，其第一个参数为当前store对象，所以能 够获取到{dispatch, commit, state, rootState }等数据</p></li><li><p>vuex 如何区分state外部直接修改，还是通过mutation 修改的？<br>  vuex中修改state唯一的渠道就是commit（‘’，payload）方法，起底层通过this._withCommit(fn)设置_committing 标志变量如果为true才能修改state，修改完会重置该变量，外部虽然也能直接修改state但是没有_committing标志位，所以只要watch一下看下是否_committing 的值为true，就可以判断修改是否合法。</p></li></ul><h3 id="keep-alive-组件的作用"><a href="#keep-alive-组件的作用" class="headerlink" title="keep-alive 组件的作用"></a>keep-alive 组件的作用</h3><ul><li>保存一些组件状态防止多次渲染，可以适用keep-alive组件包裹需要保存的组件</li></ul><h2 id="Vue-Router-的实现原理，手写一段Router代码"><a href="#Vue-Router-的实现原理，手写一段Router代码" class="headerlink" title="Vue-Router 的实现原理，手写一段Router代码"></a>Vue-Router 的实现原理，手写一段Router代码</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Hook</title>
      <link href="/wjw-blog.github.io/2020/11/16/react-hooks/"/>
      <url>/wjw-blog.github.io/2020/11/16/react-hooks/</url>
      
        <content type="html"><![CDATA[<h1 id="React-Hook"><a href="#React-Hook" class="headerlink" title="React Hook"></a>React Hook</h1><h2 id="hooks-概念"><a href="#hooks-概念" class="headerlink" title="hooks 概念"></a>hooks 概念</h2><ul><li><font color="#DC143C">Hook</font> 是 React 16.8 的新特性，它可以让你在不编写class 的情况下使用 State 以及其他的 React 特性<blockquote><p>从这句话可以得知:<b><code>Hook</code></b> 增加了函数式组件中的<b><code>State</code></b>的使用， 在函数式组件是无法拥有自己的状态的，只能通过<b><code>Props</code></b> 以及 <b><code>Content</code></b> 来渲染自己的UI， 而在业务逻辑中有些场景必须使用到<b><code>State</code></b>， 那么我们只能将函数式组件定义为<b><code>Class</code></b> 组件。 那么从现在开始， 则不需要改为<b><code>Class</code></b>组件了。</p></blockquote></li></ul><ul><li>React 16.8 加入 hooks ，让React函数式组件更加灵活</li><li>hooks 在之前React的版本存在很多问题<ol><li>在组件间复用状态逻辑（很难做到）</li><li>复杂组件变得难以理解，高阶组件加函数式组件的嵌套过深。</li><li>class 组件的this指向问题（嵌套多了，关系复杂）</li><li>难以记忆的生命周期</li></ol></li><li>hooks 很好的解决了上述的问题，hooks提供很多方法如：<ol><li>useState 返回有状态值以及更新这个状态值的函数</li><li>useEffect 接受包含命令式，有副作用代码的函数</li><li>useContent 接受上下文对象（从React.createContext 的返回值）并返回当前上下文的值</li><li>useReducer useState 的替代方案，接受类型为（state，action）=&gt; newState 的reducer 并返回与dispatch方法匹配的当前状态</li><li>useCallBack 返回一个回忆的memoized版本，该版本仅在其中一个输入发生改变时才会变更，纯函数的输入输出确定性</li><li>useMemo 纯的一个记忆函数</li><li>useRef 返回一个不可变的ref对象，其current属性能初始化传递的参数。</li><li>uselmperativeMethods 自定义使用ref时公开给父组件的实例值。</li><li>useMutationEffect 更新兄弟组件之前，它在react执行其DOM 更改的同一阶段同步触发。</li><li>useLayoutEffect Dom 改变后同步触发，使用它来从DOM读取布局并同步重新渲染</li></ol></li></ul><h2 id="React-Hook-解决了什么问题"><a href="#React-Hook-解决了什么问题" class="headerlink" title="React Hook 解决了什么问题"></a>React Hook 解决了什么问题</h2><ul><li><p><code>React Hooks</code>主要解决的是状态共享，<code>状态共享</code>单指共享状态逻辑复用，并不是指数据之间的共享。我们知道在<code>React Hooks</code>之前，解决状态逻辑复用的问题通常使用<code>higher-order components</code> 以及 <code>render DOM</code>读取布局并同步重新渲染。</p></li><li><p>既然已经有了这两种解决方案，为什么还要引入<code>React Hook</code>？ 对于<code>higher-order components</code> 以及 <code>render DOM</code>， <code>React Hook</code> 的优势是什么？</p><blockquote><p>PS: Hook 最大的优势其实还是对于状态逻辑的复用便捷，还有代码的简洁以及帮助函数组件增强功能。 </p></blockquote></li><li><p>借助官方demo代码来看下 <code>使用hooks</code></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span> useState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'React'</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">Example</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>      <span class="token operator">&lt;</span>div<span class="token operator">></span>          <span class="token operator">&lt;</span>p<span class="token operator">></span>You clicked <span class="token punctuation">{</span>count<span class="token punctuation">}</span> times<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>          <span class="token operator">&lt;</span>button onclick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span>Click me<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>如果不使用<code>hooks</code>呢？</p><pre class=" language-javascript"><code class="language-javascript">clase Example <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>commponent</span> <span class="token punctuation">{</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>            <span class="token operator">&lt;</span>div<span class="token operator">></span>                <span class="token operator">&lt;</span>p<span class="token operator">></span>You clicked <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token punctuation">}</span> times<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>                <span class="token operator">&lt;</span>button onclick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">></span>Click me<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>我们可以看到在<code>React Hooks</code>中，class example 组件变成了函数式组件，但是这个函数式组件却拥有的自己的状态，同时还可以更新自身的状态。这一切都要归功于<code>useState</code> 的 <code>Hook</code>, <code>useState</code> 会返回一对值，当前状态和一个让你可以更新它的函数（上面hook有说明），你可以在事件函数中使用或其他一些地方调用该函数，<code> class</code> 组件的<code>this.setState</code>, <font color="#DC143C">但是它不会把新的State与旧的State进行合并。</font></p></blockquote></li></ul><h2 id="深究原理-如何实现"><a href="#深究原理-如何实现" class="headerlink" title="深究原理-如何实现"></a>深究原理-如何实现</h2><ul><li><p>Hooks 的基本类型</p><pre class=" language-javascript"><code class="language-javascript">type Hooks <span class="token operator">=</span> <span class="token punctuation">{</span>    memoizedState<span class="token punctuation">:</span> any<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 指向当前渲染节点->Fiber</span>    baseState<span class="token punctuation">:</span> any<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 初始化state，已经dispatch之后的newState</span>    baseUpdate<span class="token punctuation">:</span> Update<span class="token operator">&lt;</span>any<span class="token operator">></span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 当前需要更新的Update，每次更新完成之后会赋值一个update，方便react 在渲染错误的边缘，数据回溯</span>    queue<span class="token punctuation">:</span> UpdateQueue<span class="token operator">&lt;</span>any<span class="token operator">></span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// UpdateQueue 通过</span>    next<span class="token punctuation">:</span> Hook <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token comment" spellcheck="true">// link 到下一个hooks，通过next串联每一个hooks</span><span class="token punctuation">}</span>type Effect <span class="token operator">=</span> <span class="token punctuation">{</span>    tag<span class="token punctuation">:</span> HookEffectTag<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// effectTag 标记当前hook 作用在life-cycles 的哪一个阶段</span>    create<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> mixed<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 初始化回调</span>    destory<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> mixed<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 卸载回调</span>    deps<span class="token punctuation">:</span> Array<span class="token operator">&lt;</span>mixed<span class="token operator">></span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 深度</span>    next<span class="token punctuation">:</span> Effect <span class="token comment" spellcheck="true">// link 到下一个Effect，通过next串联每一个Effect</span><span class="token punctuation">}</span></code></pre><blockquote><p>React Hooks 全局维护了一个workInProgressHook变量，每一次调取Hook API 都会先调用CreateWorkInProgressHooks 函数。</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">createWorkInProgressHooks</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>workInProgressHook <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>firstWorkInProgresshook <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            currentHook <span class="token operator">=</span> firstCurrentHook<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>currentHook <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                workInProgressHook <span class="token operator">=</span> <span class="token function">createHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 拷贝当前hook</span>                workInProgressHook <span class="token operator">=</span> <span class="token function">cloneHook</span><span class="token punctuation">(</span>currentHook<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            firstWorkInProgressHook <span class="token operator">=</span> workInProgressHook<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 已经存在 work-in-progress，直接复用</span>            currentHook <span class="token operator">=</span> firstCurrentHook<span class="token punctuation">;</span>            workInProgressHook <span class="token operator">=</span> firstWorkInProgressHook<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>workInProgresshook<span class="token punctuation">.</span>next <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">let</span> hook<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>currentHook <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                hook <span class="token operator">=</span> <span class="token function">createHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                currentHook <span class="token operator">=</span> currentHook<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>currentHook <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    hook <span class="token operator">=</span> <span class="token function">createHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    hook <span class="token operator">=</span> <span class="token function">cloneHook</span><span class="token punctuation">(</span>currentHook<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 追加到列表</span>            workInProgressHook <span class="token operator">=</span> workInProgressHook<span class="token punctuation">.</span>next <span class="token operator">=</span> hook<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            currentHook <span class="token operator">=</span> currentHook <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">?</span> currentHook<span class="token punctuation">.</span>next <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            workInProgressHook <span class="token operator">=</span> workInProgressHook<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> workInProgressHook<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>假设我们需要执行如下hooks</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">FunctionComponet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> <span class="token punctuation">[</span>stateA<span class="token punctuation">,</span>setStateA<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token punctuation">[</span>stateB<span class="token punctuation">,</span>setStateB<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'mousemove'</span><span class="token punctuation">,</span> handlerMouseMove<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>            document<span class="token punctuation">.</span><span class="token function">removeEventLisenter</span><span class="token punctuation">(</span><span class="token string">'mousemove'</span><span class="token punctuation">,</span> handlerMouseMove<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">const</span> <span class="token punctuation">[</span>stateC<span class="token punctuation">,</span> setStateC<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span>stateA<span class="token punctuation">,</span>stateB<span class="token punctuation">,</span>stateC<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>当我们了解React Hooks的简单原理，得到Hooks的串联不是一个数组，但是是一个链式的数据结构，从根节点是一个workInProgressHook向下通过next进行串联。这也就是为什么hooks <b><code>不能嵌套使用，不能在条件判断中使用，不能在循环中使用</code></b>，否则会破坏链式结构。</p></blockquote></li></ul><h1 id="hooks与生命周期"><a href="#hooks与生命周期" class="headerlink" title="hooks与生命周期"></a>hooks与生命周期</h1><ul><li><p>函数组件的本质是函数，没有state的概念的，因此不存在生命周期一说，仅仅是一个render的函数而已。</p></li><li><p>如引入<code>Hooks</code>之后就变得不同了，它能让组件在不使用class的情况下拥有state，所以就有了生命周期的概念，所谓的生命周期其实就是useState、useEffect与useLayoutEffect()。</p></li><li><p>hooks 组件（使用了hooks）有生命周期，而函数组件（没有使用hooks）没有生命周期。</p></li><li><p>生命周期class组件与hooks组件，对比如下：</p><table><thead><tr><th>class组件</th><th>hooks组件</th></tr></thead><tbody><tr><td>constructor</td><td>useState</td></tr><tr><td>getDerivedStateFromProps</td><td>useState 里面 update 函数</td></tr><tr><td>shouldComponentUpdate</td><td>useMemo</td></tr><tr><td>render</td><td>函数本身</td></tr><tr><td>componentDidMount</td><td>useEffect</td></tr><tr><td>componentDidUpdate</td><td>useEffect</td></tr><tr><td>componentWillUnmount</td><td>useEffect 里面返回的函数</td></tr><tr><td>componentDidCatch</td><td></td></tr><tr><td>getDirivedStateFromError</td><td></td></tr></tbody></table></li></ul><hr><blockquote><p>Daily Analysis 加入了一些个人想法， React Hooks 的很多方法没有具体介绍与使用，每一个Hooks函数都存在深层的涵义，比如 useMemo、useReducer 后面文章会单独讲解。Thanks～</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>斐切纳波数列</title>
      <link href="/wjw-blog.github.io/2020/11/13/js-fqnb/"/>
      <url>/wjw-blog.github.io/2020/11/13/js-fqnb/</url>
      
        <content type="html"><![CDATA[<h1 id="斐切纳波数列"><a href="#斐切纳波数列" class="headerlink" title="斐切纳波数列"></a>斐切纳波数列</h1><h2 id="实现方法-简单总结-for-while、递归"><a href="#实现方法-简单总结-for-while、递归" class="headerlink" title="实现方法 简单总结 for/while、递归"></a>实现方法 简单总结 for/while、递归</h2><ul><li><p>斐波那契数列，是指这样的一组数列： 1、1、2、3、5、8、13、21……在数学上，斐波那契数列被以递归的方法定义：F0=0，F1=1，Fn=Fn-1+Fn-2（n&gt;2, n∈N*），用文字说，就是斐波那契数列由0和1开始，之后的斐波那契数列系数就由之前的两个数相加之和。</p></li><li><p>常用的计算方法由两大类：递归/循环 ，后面会补充所有算法使用</p></li><li><p>计算的时候可以加入<code>console.time('id')</code> 与 <code>console.timeEnd('id')</code> 如果你还不知道console的用发可以<a href="'https://developer.mozilla.org/en-US/docs/Web/API/Console'">点击这里</a></p></li></ul><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="常见递归"><a href="#常见递归" class="headerlink" title="常见递归"></a>常见递归</h3><ul><li><p>优点：代码简洁清晰。</p></li><li><p>缺点：存在重复计算，浪费内存（递归是一个堆栈计算过程，数字过大会超出内存不够的情况）</p></li><li><p>example： n=5  -&gt; fib(4)+fib(3),fib(3)+fib(2) 大于50可能浏览器就出现假死现象</p><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">'runTime'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">fib</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">fib</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fib</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">fib</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//832040</span>console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">'runTime'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//runTime: 9.702880859375 ms</span></code></pre></li></ul><h3 id="优化递归：思路将前两个数作为参数避免这里的重复计算"><a href="#优化递归：思路将前两个数作为参数避免这里的重复计算" class="headerlink" title="优化递归：思路将前两个数作为参数避免这里的重复计算"></a>优化递归：思路将前两个数作为参数避免这里的重复计算</h3><ul><li><p>优点：1 .可以说省去大量重复计算，相当的快了（因为只有对应需要的才会加） 2. 代码简洁，易懂</p><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">'runTime'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">fib</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token keyword">return</span> a<span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token keyword">return</span> b<span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token keyword">else</span>       <span class="token punctuation">{</span>           <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">,</span> a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>   <span class="token punctuation">}</span>   <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">fib</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//832040</span>console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">'runTime'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//runTime: 0.105712890625 ms</span></code></pre></li></ul><h3 id="优化递归：既然可以把数字作为参数传递，那么把运算结果存储在数组内使用闭包，也能避免计算（闭包，数组引用传值）"><a href="#优化递归：既然可以把数字作为参数传递，那么把运算结果存储在数组内使用闭包，也能避免计算（闭包，数组引用传值）" class="headerlink" title="优化递归：既然可以把数字作为参数传递，那么把运算结果存储在数组内使用闭包，也能避免计算（闭包，数组引用传值）"></a>优化递归：既然可以把数字作为参数传递，那么把运算结果存储在数组内使用闭包，也能避免计算（闭包，数组引用传值）</h3><ul><li><p>优点： 利用闭包+数组计算避免，数据重复计算</p></li><li><p>缺点： 需要操作数组赋值会有相应的消耗，代码可读性不是很友好（比上面的纯数字要慢）</p><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">'runTime'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> fib <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> memo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> f <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">===</span> undefined<span class="token punctuation">)</span> <span class="token punctuation">{</span>            memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span>n <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 因外层为立即执行函数 真正使用的其实是本身 ‘f’ 函数</span>    <span class="token keyword">return</span> f<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">fib</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//832040</span>console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">'runTime'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//runTime: 0.169921875</span></code></pre></li></ul><h3 id="优化递归：既然闭包能存储计算结果那么，将计算结果直接提取成计算函数呢？"><a href="#优化递归：既然闭包能存储计算结果那么，将计算结果直接提取成计算函数呢？" class="headerlink" title="优化递归：既然闭包能存储计算结果那么，将计算结果直接提取成计算函数呢？"></a>优化递归：既然闭包能存储计算结果那么，将计算结果直接提取成计算函数呢？</h3><ul><li><p>优点：将闭包拆分出来，方便阅读理解，让函数更加纯粹</p></li><li><p>缺点：增加了逻辑判断与执行行，可能会产生一定的消耗，整体上处理时间与匿名闭包差不多</p><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">'runTime'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> memoizer <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> memo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">===</span> undefined<span class="token punctuation">)</span> <span class="token punctuation">{</span>            memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> fib <span class="token operator">=</span> <span class="token function">memoizer</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">fib</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fib</span><span class="token punctuation">(</span>n <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">fib</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//832040</span>console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">'runTime'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//runTime: 0.2080078125 ms</span></code></pre></li></ul><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="普通for-循环【迭代算法】"><a href="#普通for-循环【迭代算法】" class="headerlink" title="普通for 循环【迭代算法】"></a>普通for 循环【迭代算法】</h3><ul><li><p>优点：代码简洁易懂，纯粹的计算数值</p></li><li><p>缺点：存在多变量，需要计算赋值</p><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">'runTime'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">fib</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> sum<span class="token punctuation">;</span>   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       sum <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>       a <span class="token operator">=</span> b<span class="token punctuation">;</span>       b <span class="token operator">=</span> sum<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">fib</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//832040</span>console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">'runTime'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//runTime: 0.130126953125 ms</span></code></pre></li></ul><h3 id="for-循环【迭代算法】：-怎么改进-思路去掉sum变量，我们其实只需要第二个值即第n个的a与b的加和。比如-【a-b】-我们实际得到要的值是-b-个的【a-b】-然后去实现试试"><a href="#for-循环【迭代算法】：-怎么改进-思路去掉sum变量，我们其实只需要第二个值即第n个的a与b的加和。比如-【a-b】-我们实际得到要的值是-b-个的【a-b】-然后去实现试试" class="headerlink" title="for 循环【迭代算法】： 怎么改进 思路去掉sum变量，我们其实只需要第二个值即第n个的a与b的加和。比如 【a, b】 我们实际得到要的值是 b 个的【a + b】  然后去实现试试"></a>for 循环【迭代算法】： 怎么改进 思路去掉sum变量，我们其实只需要第二个值即第n个的a与b的加和。比如 【a, b】 我们实际得到要的值是 b 个的【a + b】  然后去实现试试</h3><ul><li><p>优点：运用解构赋值，代码简洁，省去了不必要的变量</p></li><li><p>缺点：利用数组解构，增加了复杂难度会有一定的时间消耗</p><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">'runTime'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> fib <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>b<span class="token punctuation">,</span> a <span class="token operator">+</span> b<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">return</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">fib</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//832040</span>console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">'runTime'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//runTime: 0.14599609375 ms</span></code></pre></li></ul><h3 id="while-逆向思维【迭代算法】"><a href="#while-逆向思维【迭代算法】" class="headerlink" title="while 逆向思维【迭代算法】"></a>while 逆向思维【迭代算法】</h3><ul><li><p>优点：代码简洁，省去了计算i值，比递归计算快</p></li><li><p>缺点：不易理解，取的值 b即为sum值</p><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">'runTime'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> fib <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       b <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>       a <span class="token operator">=</span> b <span class="token operator">-</span> a<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">return</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">fib</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//832040</span>console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">'runTime'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//runTime: 0.178955078125 ms</span></code></pre></li></ul><ul><li>正常来说单层for 循环运算应该是最快的&gt;优化过的递归操作&gt;普通递归 （这里从控制台输出的为什么不是这个结果呢？其实跟当前计算的数值大小有关，当计算数值大于50 或 100 以上的时候这个时间差会越来越明显。<br>  也可以理解为层数偏少的计算递归也有一定的优势 example： 普通for 300 就比 递归快 将近0.1 ms<br>  合理的选择与自己产品相应的计算方法才是最好的～</li></ul><hr><blockquote><p>因为本人是Web菜鸟理解能力有限，以上算法来自网络，经过个人整理，如有问题请留言或私信联系我指出。Thanks ～</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World - Hi Everyone</title>
      <link href="/wjw-blog.github.io/2020/11/13/index/"/>
      <url>/wjw-blog.github.io/2020/11/13/index/</url>
      
        <content type="html"><![CDATA[<h1 id="Welcome-to-Hexo-WJW-Blog"><a href="#Welcome-to-Hexo-WJW-Blog" class="headerlink" title="Welcome to Hexo-WJW-Blog"></a>Welcome to <a href="http://hexo.io/">Hexo</a>-WJW-Blog</h1><h2 id="关于本主题与Hexo"><a href="#关于本主题与Hexo" class="headerlink" title="关于本主题与Hexo"></a>关于本主题与Hexo</h2><p><a href="http://blinkfox.com/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/">可以参考这里</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
